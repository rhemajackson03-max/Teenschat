"""
TKC-style Chatroom - Single File Python App

Features:
- Flask + Flask-SocketIO real-time chat
- Username prompt, join public "Lobby" or create/join rooms
- Message broadcast per room
- Simple moderation: admin login, /kick and /ban commands
- Rate limiting, basic profanity filter, message history stored in SQLite
- REST endpoint for room list

Run:
1. python3 -m venv venv && source venv/bin/activate
2. pip install flask flask-socketio eventlet sqlalchemy
3. python tkc_clone_chatroom.py
4. Open http://localhost:5000
"""

from flask import Flask, render_template_string, request, jsonify
from flask_socketio import SocketIO, emit, join_room, leave_room, disconnect
from datetime import datetime
import sqlite3
import time
import re
import threading

# --- CONFIG ---
SECRET_KEY = 'change_this_secret'
ADMIN_TOKEN = 'change_this_admin_password'
DB_PATH = 'chat.db'
RATE_LIMIT = 1.0
MAX_MSG_LENGTH = 1000
HISTORY_LIMIT = 200
PROFANITY_WORDS = {'badword'}

# --- Flask + SocketIO ---
app = Flask(__name__)
app.config['SECRET_KEY'] = SECRET_KEY
socketio = SocketIO(app, cors_allowed_origins='*', async_mode='eventlet')

# --- SQLite helpers ---
def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            room TEXT,
            username TEXT,
            text TEXT,
            ts DATETIME
        )
    ''')
    c.execute('''
        CREATE TABLE IF NOT EXISTS bans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT,
            ip TEXT,
            reason TEXT,
            banned_at DATETIME
        )
    ''')
    conn.commit()
    conn.close()

def save_message(room, username, text):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('INSERT INTO messages (room, username, text, ts) VALUES (?, ?, ?, ?)',
              (room, username, text, datetime.utcnow()))
    conn.commit()
    conn.close()

def get_history(room, limit=HISTORY_LIMIT):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT username, text, ts FROM messages WHERE room=? ORDER BY id DESC LIMIT ?', (room, limit))
    rows = c.fetchall()
    conn.close()
    return [{'username': r[0], 'text': r[1], 'ts': r[2]} for r in reversed(rows)]

def add_ban(username=None, ip=None, reason=''):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('INSERT INTO bans (username, ip, reason, banned_at) VALUES (?, ?, ?, ?)',
              (username, ip, reason, datetime.utcnow()))
    conn.commit()
    conn.close()

def check_ban(username=None, ip=None):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    if username:
        c.execute('SELECT 1 FROM bans WHERE username=? LIMIT 1', (username,))
        if c.fetchone():
            conn.close()
            return True
    if ip:
        c.execute('SELECT 1 FROM bans WHERE ip=? LIMIT 1', (ip,))
        if c.fetchone():
            conn.close()
            return True
    conn.close()
    return False

# --- In-memory state ---
rooms = {'Lobby': set()}
user_last_msg = {}
user_meta = {}

# --- Profanity filter ---
profanity_re = re.compile(r"\b(?:" + "|".join(re.escape(w) for w in PROFANITY_WORDS) + r")\b", re.IGNORECASE) if PROFANITY_WORDS else None

# --- HTML template ---
INDEX_HTML = """
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Chatroom</title>
<style>
body { font-family: Arial; margin:0; padding:0; display:flex; height:100vh }
#sidebar { width:240px; border-right:1px solid #ddd; padding:10px }
#main { flex:1; display:flex; flex-direction:column }
#messages { flex:1; padding:10px; overflow:auto }
#input { padding:10px; border-top:1px solid #ddd }
.msg { margin-bottom:8px }
.meta { color:#666; font-size:0.9em }
.system { color:#b00 }
.room { cursor:pointer }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.1/socket.io.min.js"></script>
</head>
<body>
<div id="sidebar">
<h3>Rooms</h3>
<div id="rooms"></div>
<hr>
<label>Username: <input id="username"/></label><br>
<label>Admin token: <input id="admintoken" placeholder="optional"/></label><br>
<button id="joinBtn">Join</button>
<hr>
<strong>Active Users</strong>
<ul id="users"></ul>
</div>
<div id="main">
<div id="messages"></div>
<div id="input">
<input id="text" style="width:80%" placeholder="Type /help for commands"/>
<button id="send">Send</button>
</div>
</div>
<script>
let socket; let currentRoom='Lobby'; let username=''; let isAdmin=false;
function addMessage(html){const d=document.createElement('div');d.className='msg';d.innerHTML=html;document.getElementById('messages').appendChild(d);document.getElementById('messages').scrollTop=document.getElementById('messages').scrollHeight;}
async function fetchRooms(){const res=await fetch('/rooms');const j=await res.json();const container=document.getElementById('rooms');container.innerHTML='';j.rooms.forEach(r=>{const el=document.createElement('div');el.textContent=r+' ('+j.counts[r]+')';el.className='room';el.onclick=()=>{if(username) joinRoom(r)};container.appendChild(el);});}
function joinRoom(room){socket.emit('join',{room});currentRoom=room;document.getElementById('messages').innerHTML='';addMessage('<div class="system">Joined '+room+'</div>');}
function bindUI(){document.getElementById('joinBtn').onclick=()=>{username=document.getElementById('username').value.trim();const token=document.getElementById('admintoken').value.trim();if(!username) return alert('Enter username');socket=io();socket.on('connect',()=>{socket.emit('introduce',{username,token});});socket.on('message',m=>{addMessage('<span class="meta">['+m.ts+'] <b>'+m.username+':</b></span> '+m.text);});socket.on('system',m=>{addMessage('<span class="system">'+m+'</span>');});socket.on('history',hist=>{hist.forEach(h=>addMessage('<span class="meta">['+h.ts+'] <b>'+h.username+':</b></span> '+h.text));});socket.on('user_list',list=>{const ul=document.getElementById('users');ul.innerHTML='';list.forEach(u=>{const li=document.createElement('li');li.textContent=u;ul.appendChild(li);});});fetchRooms();};document.getElementById('send').onclick=()=>{sendText();};document.getElementById('text').addEventListener('keydown',ev=>{if(ev.key==='Enter') sendText();});}
function sendText(){const t=document.getElementById('text').value.trim();if(!t)return;if(t.startsWith('/')){socket.emit('command',{cmd:t});}else{socket.emit('chat',{room:currentRoom,text:t});}document.getElementById('text').value='';}
bindUI();setInterval(fetchRooms,5000);
</script>
</body>
</html>
"""

# --- ROUTES ---
@app.route('/')
def index(): return render_template_string(INDEX_HTML)

@app.route('/rooms')
def list_rooms():
    counts = {r: len(users) for r, users in rooms.items()}
    return jsonify({'rooms': list(rooms.keys()), 'counts': counts})

# --- SOCKET HANDLERS ---
@socketio.on('connect')
def handle_connect():
    sid = request.sid
    ip = request.remote_addr
    user_meta[sid] = {'username': None, 'room': None, 'ip': ip, 'is_admin': False}
    emit('system', 'Connected. Please introduce yourself with a username.')

@socketio.on('disconnect')
def handle_disconnect():
    sid = request.sid
    meta = user_meta.get(sid)
    if meta:
        uname = meta.get('username')
        room = meta.get('room')
        if room and uname in rooms.get(room, set()):
            rooms[room].remove(uname)
            socketio.emit('user_list', list(rooms[room]), to=room)
        user_meta.pop(sid, None)

@socketio.on('introduce')
def handle_intro(payload):
    sid = request.sid
    username = re.sub(r'[^A-Za-z0-9_- ]+', '', payload.get('username',''))[:32]
    token = payload.get('token','')
    ip = request.remote_addr
    if check_ban(username=username, ip=ip):
        emit('system','You are banned.')
        disconnect()
        return
    user_meta[sid].update({'username': username, 'is_admin': token==ADMIN_TOKEN})
    join_room('Lobby')
    user_meta[sid]['room'] = 'Lobby'
    rooms.setdefault('Lobby', set()).add(username)
    emit('system', f'Welcome {username}! Joined Lobby.')
    hist = get_history('Lobby')
    emit('history', hist)
    socketio.emit('user_list', list(rooms['Lobby']), to='Lobby')

@socketio.on('join')
def handle_join(payload):
    sid = request.sid
    meta = user_meta.get(sid)
    if not meta or not meta.get('username'): return
    old = meta.get('room')
    new = payload.get('room','Lobby')
    uname = meta['username']
    if old and uname in rooms.get(old, set()):
        rooms[old].remove(uname)
        leave_room(old)
        socketio.emit('user_list', list(rooms[old]), to=old)
    rooms.setdefault(new, set()).add(uname)
    join_room(new)
    meta['room'] = new
    emit('system', f'Joined {new}')
    hist = get_history(new)
    emit('history', hist)
    socketio.emit('user_list', list(rooms[new]), to=new)

@socketio.on('chat')
def handle_chat(payload):
    sid = request.sid
    meta = user_meta.get(sid)
    if not meta or not meta.get('username'): return
    ip = meta.get('ip')
    if check_ban(username=meta['username'], ip=ip):
        emit('system','You are banned.')
        disconnect()
        return
    now = time.time()
    last = user_last_msg.get(sid,0)
    if now - last < RATE_LIMIT:
        emit('system','You are sending messages too fast.')
        return
    user_last_msg[sid] = now
    text = payload.get('text','')[:MAX_MSG_LENGTH]
    if profanity_re and profanity_re.search(text):
        text = profanity_re.sub('[censored]', text)
    room = meta.get('room','Lobby')
    ts = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
    save_message(room, meta['username'], text)
    socketio.emit('message', {'username': meta['username'], 'text': text, 'ts': ts}, to=room)

# --- BACKGROUND CLEANUP ---
def room_cleanup_loop():
    while True:
        to_delete = [r for r,u in rooms.items() if len(u)==0 and r!='Lobby']
        for r in to_delete: rooms.pop(r, None)
        time.sleep(30)

# --- STARTUP ---
if __name__ == '__main__':
    init_db()
    t = threading.Thread(target=room_cleanup_loop, daemon=True)
    t.start()
    print("Starting chat server on http://0.0.0.0:5000")
    socketio.run(app, host='0.0.0.0', port=5000)